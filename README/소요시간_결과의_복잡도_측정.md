# 할일관리 애플리케이션

### 소요시간 결과의 복잡도 측정

```
프로그램을 구현하다보면 알고리즘 마다 소요되는 시간이 달라진다.

for문과 같은 반복처리를 하는 경우 반복해야 할 갯수가 증가함에따라 그 문제는 심각해질 수 있다. 따라서 더 빠른 알고리즘을 적용할 수 있다면 그렇게 해야 한다.

시간복잡도가 어떤 것인지 학습해보자. (키워드 : Big-O Complexity)

지금 구현한 방법이 어떤 시간복잡도를 가진 것인지 비교해보자. 더 빠른 방법은 어떤 것인지 알아본다.

만일 본인이 구현한 방법이 가장 빠른 방법이였다면 더 느린 방법으로 구현해보고 코드를 비교해본다.
```

- ### 시간 복잡도

  - 시간 복잡도를 이용하면 작성한 코드가 시간이 얼마나 걸릴지 예상
  - 표기법으로 대문자 O 를 사용
  - 영어로는 Big O Notation
  - 입력의 크기에 대해서 시간이 얼마나 걸릴지 나타내는 방법
  - 최악의 경우에 시간이 얼마나 걸릴지 나타내야함

  ```c++
  int sum = 0;
  for (int i=0; i<=N; i++) {
      sum += i;
  }
  // 시간복잡도 O(N)
  ```

  ```c
  int sum = 0;
  sum = N * (N+1)/2;
  // 시간복잡도 O(1)
  ```

  ```c++
  int sum = 0;
  for (int i=1; i<=n; i++) {
      for (int j=1; j<=n; j++) {
          if (i == j) {
              sum += j;
          }
      }
  }
  // 시간복잡도 O(N^2)
  ```

  - O(1) : 상수(Constant) 형태
  - O(lgN) : 로그(Logarithmic) 형태
  - O(N) : 1억 : 선형
  - O(NlgN) : 5백만 : 선형로그 형태
  - O(N^2) : 1만 : 다차(Polynomial) 형태
  - O(N^3) : 500 : 다차(Polynomial) 형태
  - O(2^N) : 20 (1,048,576) : 지수(Exponential) 형태
  - O(N!) : 10 (3,628,800) : 팩토리얼(Factorial) 형태
  - 시간복잡도 안에 가장 큰 입력범위를 넣었을 때, 1억이 1초정도이다

- ### 시간 복잡도 계산

  - O(1) : 단순 계산 (a+b와 같은 연산, 배열에 접근하는 연산)
  - O(lgN) : N개를 절반으로 계속해서 나눔
  - O(N) : 1중 for문
  - O(NlgN)
  - O(N^2) : 2중 for문
  - O(N^3) : 3중 for문
  - O(2^N) : 크기가 N인 집합의 부분 집합
  - O(N!) : 크기가 N인 순열
    - 알고리즘의 순서가 다를때 (123, 132 ...)
  - 시간복잡도의 의미를 알고있는것은 매우 중요
  - 코드를 작성하고, 시간을 계산하는것도 중요하지만
  - 구현을 하기 전에, 구현을 어떻게 해야겠다 라고 생각한 후
  - 시간복잡도를 계산해본 다음, 문제의 시간 내에 해결할 수 있는지 확인
  - 익숙해져야 할 부분임

- ### 시간 복잡도 계산

  - Big O Notation 에서 상수는 버림
  - O(3N^2) = O(N^2)
  - O(1/2N^2) = O(N^2)
  - O(5) = O(1)
  - 두가지 항이 있을 때, 변수가 같으면 큰 것만 빼고 다 버린다
  - O(N^2 + N) = O(N^2)
  - O(N^2 + NlgN) = O(N^2)
  - 두 가지 항이 있는데 변수가 다르면 놔둔다.
  - O(N^2 + M)

- ### 활용

  실무 프로그래밍에서 로직의 소요 시간이라는 요소가 가지고 있는 중요성을 생각했을 때, 매우 중요한 요소임에는 틀림없으나 어째서인지 양산형 코더들은 물론이거니와 컴퓨터공학 전공자들 중에서도 관심을 가지는 사람이 별로 없다. 그러나, **상용 소프트웨어 개발에서는 n^2n2와 n^3n3 알고리즘의 차이는 단지 몇 초~수 분 차이일 뿐**이지만 **이를 사용하는 사용자 입장에서는 충분히 느낄 수 있을 정도기에 그 중요성은 매우 크다.** 

  예를 들어, 내부 알고리즘이 느려서 버튼 하나 누를 때 마다 5초간 기다리다가 다음 작업을 하는 것과 1초 미만의 시간을 기다리고 다음 작업을 하는 것은 상당히 큰 차이가 있다. 모 게임에서는 n^5n5 만큼의 시간복잡도를 가지는 알고리즘이 적용되어 있던 내부 모듈을 **n^3n3 만큼의 시간복잡도를 가지게 개선하여 유저들의 극 호평을 받은 적**이 있다.



- ### 공간복잡도

  알고리즘의 **메모리 사용량**에 대한 분석결과

  크기가 n인 배열을 입력했는데, 알고리즘 내부에서 n x n의 2차원 배열을 생성한다면, 해당 알고리즘의 공간복잡도는 `n^2` 이 되는 것

  ​

  ​