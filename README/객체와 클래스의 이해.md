# 객체와 클래스의 이해

- ### 객체

  모든것이 `객체`다

  어떠한 사물 === `Object`

  현실세계를 인지하면서 프로그래밍을 하자

  상상하고, 볼 수 있고, 만질 수 있는 것들은 모두 `객체`이다



- ### 객체의 구성

  모든 `객체`는 `속성(Property)` 과 `행위(Method)` 를 가질 수 있음

  - 속성 : 사람의 키, 나이, 몸무게
  - 행위 : 움직이다, 먹다, 자다, 공부하다

  ```javascript
  Class {
    this.height = 180;  //property
    this.age = 22;  //property
    eat = function() {}  //method
  }
  ```

  - 속성 = 필드 = Property
  - 함수 = 메서드 = Method



- ### 클래스와 객체

  - #### class

    어떠한 객체를 표현하기 위해, **일반화된 형태**로 만든 것

    **집합**이나 **분류**에 가까움 (사람, 동물, 자동차 등)

  - #### object (instance)

    class 를 통해서 얻을 수 있는 개별 `객체`

    유일한 사물

    실체에 가깝다 (crong, 사자, 벤츠)

  - ### console.log

    `console` : 객체 (인스턴스)

    `log` : 메서드 (함수)

  - ### OOP 핵심개념

    Class

    캡슐화 (Encapsulation)

    상속 (Inheritance)

    다형성 (Polymorphism)

    추상화 (Abstraction)

  - ### OOP & Javascript

    1. #### Class

       Javascript는 class 없이 프로그래밍이 가능함

       또한 Class가 존재하고 있지만, 함수가 일종의 클래스 역할

    2. #### 캡슐화 (Encapsulation)

       내부에서만 알고있으면 될 것을 외부에 공개하지 않음

       필요한 것은 외부에 접근을 허용

       `Private` `Public`

       Javascript 는 이를 공식지원하지 않음

       `Module Pattern` 을 통해서 구현은 가능

    3. #### 상속 (Inheritance)

       공통부분을 분리해서 재사용하려는 목적

       상위클래스 - 하위클래스 간 연결

       동동 - 사람, BMW - 자동차, 포크레인 - 중장비

       아들 - 아빠 (X)

       Kind of 관계

    4. ### 다형성 (Polymorphism)

       다양한 성질로 동작

       OverRiding 을 통한 재정의

       OverLoading 을 통한 메서드 중복정의

       Javascript 는 Prototype Chain 내에 동일한 메서드를 두고 OverRiding 구현은 가능

       하지만, Interface 가 없고, Method OverLoading 을 공식지원하지 않음

       (다만, 어떤 타입을 체크해서, 다른 메서드를 호출해서 실행하도록 구현할 수 있음)

       JavaScript에 다형성이 존재하는가는 중요한 논쟁거리는 아님

    5. ### 추상화 (abstraction)

       필요한 부분만을 선택해서 클래스를 만드는 것

       `차`는 `버스` 클래스와 `중장비` 클래스로 구분지을 수 있는데

       버스와 중장비는 **서로 다른속성과 행위가 필요**

       이렇게 필요한 부분을 선택해서 클래스를 만들 수 있고

       이를 **추상화**라고 함

    6. ### 좋은 OOP

       높은 응집도 (High Cohesion)

       낮은 결합도 (Loose Coupling)

       [SOLID 원칙](https://namu.wiki/w/%EA%B0%9D%EC%B2%B4%20%EC%A7%80%ED%96%A5%20%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%B0%8D/%EC%9B%90%EC%B9%99)

    7. ### 프론트엔드에서는 OOP를 ?

       화면에 보이는 UI요소, 어떠한 제어를 하는 비 UI 요소 등,

       모든 것을 모듈로 만들어서 개발할 수 있음

       여기서 `모듈`은 **객체 (Class 형태)** 임

       Javascript 세계에서 **객체의 표현방식은 다양**함

    8. ### 객체표현 - Obejct Literal

       Class 없이 바로 Object 로 표현 가능 #Singleton

       ```javascript
       var healthObj = {
         name : "달리기",
         lastTime : "PM10:12",
         showHealth : function() {
           console.log(this.name + "님, 오늘은 " + this.lastTime + "에 운동을 하셨네요");
         }
       }

       healthObj.showHealth();
       ```

    9. ### 객체표현 - [Class ES6](https://caniuse.com/#feat=es6-class)

       Class 에서 **생성자 (constructor)** 가 주어짐

       Class 를 호출하면 **Constructor 이 자동호출**됨

       Constructor은 **객체 (instance) 를 만들어서 반환**

       ```javascript
       const Health = class {
         constructor(name,healthTime) {
           this.name = name;
           this.healthTime = healthTime;
         }

         showHealth(){
            debugger;
            console.log(this.name + "님, 오늘은 " + this.healthTime + "에 운동을 하셨네요");
         }

       }

       const ho = new Health("crong", "12:12");
       ho.showHealth();
       ```

    10. ### 객체표현 - Class ES3

        function 을 new 키워드로 호출하면

        해당 함수는 Constructor 이 됨

        ```javascript
        const Health = function(name,healthTime) {
          this.name = name;
          this.healthTime = healthTime;
          this.showHealth = function() {
            console.log(this.name + "님, 오늘은 " + this.healthTime + "에 운동을 하셨네요");
          }
        }

        const ho = new Health("crong", "12:12");
        ho.showHealth();
        ```

    11. ### 객체표현 - Prototype Object ES3

        ```javascript
        const Health = function(name, healthTime) {
          this.name = name;
          this.healthTime = healthTime;
        }

        Health.prototype.showHealth = function() {
          console.log(this.name + "님, 오늘은 " + this.healthTime + "에 운동을 하셨네요");
        }

        const ho = new Health("crong", "12:12");
        ho.showHealth();
        ```

    12. ### 객체표현 Object.create ES5

        Object.create 는 직접적으로 Prototype 키워드를 사용하진 않지만

        Prototype Object를 만드는 것과 동일

        ```javascript
        const healthObj = {
          showHealth : function() {
            console.log(this.name + "님, 오늘은 " + this.healthTime + "에 운동을 하셨네요");
          }
        }

        const ho = Object.create(healthObj, {
           name: { value: "crong" },
           healthTime: { value: "12:22" } 
        })

        ho.showHealth();
        ```

        Object.create 는 Prototype 기반 상속을 좀 더 매끄럽게 사용하기 위해 탄생했다고 이해할 수 있음

        Object.create를 사용하면 상속구조가 잘 만들어짐

        ES6 Classes의 extend를 사용해서

        보다 쉽게 클래스간 상속구조를 만들 수 있게됨

    13. ### Object Literal vs Class

        - Object Literal

          여러개의 객체를 만들어서 생성할 필요가 없을 때

          즉, 일반화할 필요가 없는 경우에는

          단순히 Object Literal로 객체를 표현

        - Class

          하나 이상으로 개별적인 객체를 생성해야 할 때















